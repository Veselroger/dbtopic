# [←](./README.md) <a id="home"></a> Database topics

## Table of Contents:
- [Intro](#intro)
- [Connection](#connection)
- [SQL query](#query)
- [Transactions](#transaction)
    - [Anomalies](#anomalies)
    - [Isolation levels](#isolation)
- [Locks](#locks)
- [Indexes](#index)
- [Databases](#db)
    - [Schemas](#schemas)
    - [Tables](#tables)
    - [Joins](#joins)
    - [Groups](#groups)
- [Interactive exercises](#tutorial)
----

## [↑](#home) <a id="intro"></a> Intro
**База данных** - это совокупность данных, которые хранятся в соответствии с некоторой схемой и работа с которыми выполняется в соответствии с некоторыми правилами. В общем и целом, база данных - это источник данных, поэтому зачастую при работе с базами данных используют понятие **"DataSource"**. 

Базы данных в свою очередь можно разделить на **реляционные** и **нереляционные**. Первые часто называют SQL базами данных, а вторые - NoSQL. Дальше речь пойдёт об SQL базах данных.

**SQL (Structured Query Language)** - это язык запросов, при помощи которых мы можем каким-либо образом влиять на БД. Чаще всего выделяют **DDL (Data Definition Language)**, при помощи которого мы меняем структуру БД (как хранятся данные) и **DML (Data Manipulation Language)**, при помощи которого мы меняем сами данные. Есть ещё и другие, но их редко специально обозначают, но подробнее можно прочитать в разделе **"[Что такое DDL, DML, DCL и TCL](https://info-comp.ru/what-is-ddl-dml-dcl-tcl)"**.

База данных сама по себе - это хранилище. Этим хранилищем кто-то должен управлять.\
Базами дынных управляют **Системы Управления Базами Данных (СУБД)**, они же **Database Management System (DBMS)**. Существуют различные СУБД. 

Выберем одну из СУБД, например **PostgreSQL**. СУБД прежде всего это клиент-серверное приложение, т.е. СУБД является сервером, который принимает от клиента запросы и возвращает результат. СУБД могут быть установлены локально, так и удалённо. В качестве удалённого сервера можно воспользоваться услугой **PostgreSQL as a Service**, например от **[ElephantSQL](https://www.elephantsql.com/)**. ElephantSQL предоставляет возможность создать экземпляр базы данных не устанавливая СУБД локально, а работая с ним по сети.

В качестве источников информации рекомендуются следующие ресурсы:
- официальная документация: **"[PostgreSQL 11.13 Documentation](https://postgrespro.ru/docs/postgresql/11)"**.
- руководства с сайта **[postgresqltutorial.com](www.postgresqltutorial.com)**

В случае, если локально был установлен PostgreSQL, но от него забыт пароль, то можно воспользоваться материалом "[как сбросить пароль](https://www.postgresqltutorial.com/postgresql-reset-password/)".

Для подключения к БД из VS Code можно использовать **[VSCode SQLTools](https://vscode-sqltools.mteixeira.dev/)**.

Кроме того, полезно ознакомиться с темой "[PostgreSQL Roles](https://www.postgresqltutorial.com/postgresql-administration/postgresql-roles/)".


## [↑](#home) <a id="connection"></a> Connection
При работе с базами данных для нас, как клиента, они сетевой ресурс. Для доступа к БД используется **URL**, т.е. **Uniform Resource Locator**. Часто его называют **Connection String**.

URL начинается с протокола. Например, для работы с БД PostgreSQL URL начинается с **"postgres://"**. Полная строка подключения включает имя пользователя, пароль, хост, порт и название базы данных. Например:
> postgres://userName:password@chunee.db.elephantsql.com:5432/databaseName

Чтобы начать работу с БД с ней устанавливается соединение (**Connection**). Создание новой сессии - трудоёмкий процесс, поэтому чтобы каждый раз не создавать соединение часто используют пулы соединений на стороне клиента БД. Кроме того, на стороне СУБД есть лимит на количество подключений, что тоже является причиной выбора пулов подключений к БД.

Подробнее про подключения см. **"[51.2. How Connections are Established](https://www.postgresql.org/docs/11/connect-estab.html)"**.

После того, как соединение установлено мы можем отправлять на сторону СУБД наши SQL запросы.


## [↑](#home) <a id="query"></a> SQL query
Используя подключение к БД мы можем выполнять SQL запросы. Каждый запрос отсылается простым текстом на сторону СУБД, где этот текст проходит различные этапы.

**[The Parser Stage](https://www.postgresql.org/docs/11/parser-stage.html)**:\
Самая первая стадия, на которой поступивший на сторону СУБД текст запроса проверяется на корректность и из него строится синтаксическое дерево.

Данная стадия после построения дерева заканчивается **[трансформацией](https://www.postgresql.org/docs/11/parser-stage.html#id-1.10.3.6.4)**. Трансформация превращает синтаксическое дерево в **"query tree"**. Анализ этого query tree требует наличия транзакции, поэтому в момент парсинга мы можем понять, полученный запрос это **Transaction control commands (BEGIN, ROLLBACK)** или обычный запрос. И в соответствии с этим принимать решение о создании транзакции.

Далее, сформированное **[Query Tree](https://www.postgresql.org/docs/11/querytree.html)** поступает в планировщик.

**[Planner/Optimizer](https://www.postgresql.org/docs/11/planner-optimizer.html)**:\
Планировщик на основе синтаксического дерева будет строить планы запроса. В худшем случае планировщик всегда может использовать последовательное сканирование таблиц (**Sequential scan**), а если для таблиц есть индексы он может воспользоваться и **Index scan**.

Если же используется объединение таблиц, тогда могут быть использованы следующие подходы:
- **[Nested loop join](https://bertwagner.com/posts/visualizing-nested-loops-joins-and-understanding-their-implications/)**
- **[Merge join](https://bertwagner.com/posts/visualizing-merge-join-internals-and-understanding-their-implications/)**
- **[Hash join](https://bertwagner.com/posts/hash-match-join-internals/)**

**[Executor](https://www.postgresql.org/docs/11/executor.html)**:\
Далее, выбирается наиболее оптимальный план запроса и поступает на выполнение в **Executor**.

Выполнение SQL запроса выполняется в определённом порядке. Подробнее см:
- [SQL Query order](https://www.sisense.com/blog/sql-query-order-of-operations/)
- [SELECT queries order of execution](https://sqlbolt.com/lesson/select_queries_order_of_execution)

Таким образом, для работы с БД мы должны установить соединение, а каждый запрос выполняется в рамках транзакции. То есть любой запрос выполняется в рамках транзакции, явно или не явно.


## [↑](#home) <a id="transaction"></a> Transactions
SQL строится на таком требовании как **ACID**. Одним из главных понятий в котором используется **Транзакция**. Как ранее было сказано, любой запрос явно или неявно выполняется в транзакции. Про транзакции есть шикарный доклад от **Martin Kleppmann**: **[Transactions: myths, surprises and opportunities](https://youtu.be/5ZjhNTM8XU8?t=403)**.

Транзакции позволяют контролировать одновременный доступ к данным и решают проблемы возникновения "аномалий" при одновременной работе с одними и теми же данными.

### [↑](#home) <a id="anomalies"></a> Anomalies
**Грязное чтение (dirty read)** - аномалия, при которой одна транзакция видит изменения другой транзакции ещё до того, как они были подтверждены (за**commit**чены).

**Неповторяющееся чтение (non-repeatable read)** - аномалия, при которой одна транзакция читает одни и те же данные, но при этом получает разный результат. Это может произойти, если между чтениями другая транзакция сможет изменить эти данные.

**Потерянное обновление (lost update)** - аномалия, при которой несколько транзакций меняют одни и те же данные (например, прибавляют значение к полученному из запроса результату) и при этом результат одних транзакций может быть перезаписан другими транзакциями. В таком случае какие-то резульаты будут "потеряны".

**Фантомное чтение (phantom reads)** - аномалия, похожая на non-repeatable read, но её смысл в том, что между разными чтениями будут добавлены/удалены строчки, и таким образом выполняя один и тот же запрос мы получим разное кол-во данных.


### [↑](#home) <a id="isolation"></a> Isolation levels
Говоря про транзакции стоит помнить и про механизмы изоляции транзакций. Существует два основных механизма: при помощи "локов" и при помощи **Multiversion concurrency control (MVCC)**. PostgreSQL использует MVCC. Если кратко, то у каждой транзакции есть свой ID, его можно даже получить в запросе: ``SELECT txid_current();``. У каждой строки в БД есть 2 колонки (xmin и xmax), которые видны только самой СУБД. В одной колонке написано начиная с какой транзакции строка видна, а другая колонка говорит до какой транзакции видна данная версия. Кроме того, статусы транзакций хранятся в infomask, по которой можно понять, был ли коммит или ролбэк транзакции.

Существует отличный цикл статей на эту тему: **"[MVCC-1. Изоляция](https://habr.com/ru/company/postgrespro/blog/442804/)"**. А так же можно посмотреть доклад: **"[Postgres, MVCC, and you or, Why COUNT(*) is slow (David Wolever)](https://www.youtube.com/watch?v=GtQueJe6xRQ)"**.

Чтобы избежать аномалии существуют разные уровни изоляции транзакций:
- **Read uncommitted**
Можно читать даже те изменения, которые незаcommitчены. Самая минимальная изолированность, точнее её отсутствие. При этом все аномалии будут воспроизводится. Такой уровень изоляции может вообще не поддерживаться БД (например, PostgreSQL не поддерживает).
- **Read committed**
На этом уровне мы видим всё, что было успешно закомичено. Таким образом мы смотрим на xmin и xmax и решаем, видна ли нам строка. Получается, что главное, чтобы не было xmax в статусе committed.
- **Repeatable Read**
На этом уровне мы видим те строки, которые были видны на момент старта нашей транзакции. Получается, что xmin должен быть подтверждён до нашей транзакции и не должно быть xmax, меньшего или равного нашей транзакции. Таким образом, создаётся своего рода "снимок" (snapshot), который и виден нашей транзакции. Поэтому MVCC называют протоколом изоляции на основе снимков (Snapshot Isolation).
- **Serializable**
Самый сильный уровень изоляции. Он работает похоже на Repeatable read, но добавляются так называемые "предикатные" блокировки, которые позволяют отслеживать факт того, что запись могла бы повлиять на результат предыдущего чтения параллельной транзакции, если бы эта запись выполнялась сначала. Хороший пример приведён в документации PostgreSQL: **"[Уровень изоляции Serializable](https://postgrespro.ru/docs/postgrespro/9.5/transaction-iso#xact-serializable)"**.


## [↑](#home) <a id="locks"></a> Locks
Даже применяя MVCC механизмы блокировок (локов) не исчезли. PostgreSQL поддерживает разные блокировки, подробнее о них можно прочитать в цикле статей: **"[Блокировки в PostgreSQL](https://habr.com/ru/company/postgrespro/blog/462877/)"**.

На тему блокировок есть отличный доклад: **"[Егор Рогов: Блокировки в PostgreSQL](https://www.youtube.com/watch?v=_R2-IsKfsUU)"**.

Кроме того, на тему блокировок есть цикл статей: **"[Блокировки в PostgreSQL](https://habr.com/ru/company/postgrespro/blog/462877/)"**.

Существуют разные блокировки. Их можно представить в виде [матрицы совместимости](https://postgrespro.ru/docs/postgresql/10/explicit-locking#LOCKING-TABLES). Если блокировки "конфликтуют", это значит, что при наличии одних блокировок другие блокировки нельзя будет взять до момента освобождения первых. Полученная транзакцией блокировка обычно сохраняется до конца транзакции (происходит **Two-Phase Locking** - сначала фаза захвата блокировок, а после коммита транзакции - фаза освобождения блокировок).


## [↑](#home) <a id="index"></a> Indexes
Индексы - специальные структуры, которые помогают сделать выполнение SQL запросов эффективнее.

Более подробно про индексы можно прочитать в следующих материалах:
- [Индексы в PostgreSQL](https://habr.com/ru/company/postgrespro/blog/326096/)
- [Geekific : B-Trees](https://www.youtube.com/watch?v=SI6E4Ma2ddg)

То, какие индексы будут использованы, можно увидеть при помощи команды **"[EXPLAIN](https://www.postgresql.org/docs/current/sql-explain.html)"**.

Explain оценивает время выполнения, а так же "цену" (cost) выполнения. Более подробно см. **"[PostgreSQL EXPLAIN – What are the Query Costs?](https://scalegrid.io/blog/postgres-explain-cost/)"**.

-------------

## [↑](#home) <a id="db"></a> Databases
### [↑](#home) <a id="schemas"></a> Schemas
Начать стоит с понимания того, что такое **"Схема"**.

**Схема ([Schema](https://www.postgresqltutorial.com/postgresql-schema/))** - это пространство имён в терминах баз данных. В разных БД они реализованы по-разному. В oracle схемы и пользователь - это одно и тоже. В PostgreSQL схемы и пользователи - разные сущности.

В PostgreSQL информация о схемах даже хранится в таблице под названием **pg_namespace**. Благодаря схемам СУБД (например, PostgreSQL) может разрешить конфликты имён и настроить права доступа. Кроме того, в любой момент времени при запросе используется та или иная схема, даже если она не указана. В этом случае PostgreSQL будет использовать специальную переменную **search_path**, которую можно прочитать при помощи команды ``SHOW search_path;``.

Подсмотрим в материал **"[PostgreSQL CREATE SCHEMA](https://www.postgresqltutorial.com/postgresql-create-schema/)"**. Т.к. работа со схемами - это DDL, то создание схемы начинается с "CREATE <что создать> <имя объекта>". 

Схему можно создать при помощи SQL команды ``CREATE SCHEMA myschema;``. Кроме того, данная схема может быть добавлена в search path при помощи команды ``SET search_path TO myschema;``.

В свою очередь схемы являются контейнерами для таблиц.


### [↑](#home) <a id="tables"></a> Tables
В реляционных базах данных эти самые данные организованы при помощи таблиц. Таблицы состоят из записей (**records**), которые являются строками таблицы. Каждая запись состоит из полей (**fields**), которые являются колонками/столбцами. Подробнее можно прочитать тут: **"[Fields & Records in a Database](https://www.techwalla.com/articles/differences-between-fields-records-in-a-database)"**.

Синтаксис создания таблиц можно увидеть в материале **"[PostgreSQL CREATE TABLE syntax](https://www.postgresqltutorial.com/postgresql-create-table)"**. Например:
```sql
CREATE TABLE roles(
   role_id serial PRIMARY KEY,
   role_name VARCHAR (255) UNIQUE NOT NULL
);
```

Важно понимать, что Системы Управления БД должны как-то уметь отличать одну строку от другой. Поэтому разные БД делают это по-разному. Например, PostgreSQL имеет внутреннюю колонку "OID", подробнее можно прочитать в обсуждении темы **"[Table with no primary key](https://www.postgresql.org/message-id/web-690678@davinci.ethosmedia.com)"**. Однако в SQL есть правильное решение - **[PRIMARY KEY](https://www.postgresqltutorial.com/postgresql-primary-key/)**, он же первичный ключ.

**Первичный ключ** - это сочетание двух других констрейнтов: NOT NULL + UNIQUE. Интересно, что UNIQUE констрейнт и UNIQUE индекс - это разные "сущности" базы данных. Констрейнты - это часть стандарта SQL. Можно назвать это спецификацией или описание контракта, что что-то должно себя определённым образом (например, должны быть уникальны). Индексы же это конкретная реализация на стороне БД, которая зависит от самой БД. Таким образом создавая констрейнты БД реализует их своим образом. Например, создавая UNIQUE констрейнт "под капотом" создаётся UNIQUE индекс для реализации требований уникальности.

Первичный ключ может состоять как из одного поля, так и из нескольких. Кроме того, первичный ключ может быть естественным (natural key), т.е. отражающим реальные данные вроде ISBN кода книги, так и суррогатным (surrogate key), т.е. искуственно введённым в качестве ID колонки. Эти особенности используются в различных фрэймворках, таких как Hibernate.

Кроме того, первичный ключ может быть указан при помощи [Identity Column](https://www.postgresqltutorial.com/postgresql-identity-column/).

**Вторничный ключ ([FOREIGN KEY](https://www.postgresqltutorial.com/postgresql-foreign-key/))** - это ссылка из столбца одной таблицы на PK другой таблицы. Благодаря вторичным ключам обеспечивается консистентность данных. Например, нельзя указать ID пользователя которого нет.

Интересно, что у вторичного ключа может быть указан параметр **ON DELETE**, чтобы определёнными действиями поддерживать консистентность данных. Есть три варианта: ON DELETE CASCADE, ON DELETE SET NULL и ON DELETE SET DEFAULT.


### [↑](#home) <a id="joins"></a> Table Join
Запросы часто используют несколько таблиц. В этом случае происходит объединение этих таблиц или **Join**.\
Объединение таблиц может быть явным (**[explicit](https://www.postgresql.org/docs/current/explicit-joins.html)**) и неявным (**implicit**).

Явное объединение - использование синтаксиса **Join**, который бывает **inner** и **outer**.\
**Outer** (внешнее) объединение может быть **left** и **right**.\
Подробнее см. **"[SQL Joins Explained](https://www.youtube.com/watch?v=9yeOJ0ZMUYw)"** и **"[Типы объединений в SQL](https://www.youtube.com/watch?v=n-5RLxezWh8)"**.


### [↑](#home) <a id="groups"></a> GROUPS
Группировка позволяет "схлопнуть" результат запроса, выполнив какие-нибудь агрегирующие действия.
Для группировки используется выражение **"GROUP BY"**, который выполняется после FROM и WHERE.
Стоит отметить, что у GROUP BY есть своё условие, указываемое через **HAVING**. Всё это выполняется ДО **SELECT**, а значит и псевдонимы (алиасы) нельзя использовать. Однако, некоторые СУБД (например, PostgreSQL) могут делать некоторые допущения и отходить от стандарта. Подробнее см: "**[Column aliases for GROUP BY and HAVING](https://www.postgresql.org/message-id/7608.1259177709%40sss.pgh.pa.us)**".

Подробнее можно посмотреть здесь:
- [SQL Lesson 10: Queries with aggregates](https://sqlbolt.com/lesson/select_queries_with_aggregates)
- [Андрей Созыкин: Группировки и фильтрация в SQL](https://www.youtube.com/watch?v=ytfXUvCsNuo)


## [↑](#home) <a id="tutorial"></a> Interactive exercises
Интерактивные сайты с упражнениями:
- [SQLBolt](https://sqlbolt.com/)
- [SQL-ex](https://www.sql-ex.ru)
- [Hackerrank : SQL](https://www.hackerrank.com/domains/sql)